// Code generated by protoc-gen-go. DO NOT EDIT.
// source: nigori_local_data.proto

package sync_pb

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type CryptographerData struct {
	// Contains all known Nigori keys.
	KeyBag *NigoriKeyBag `protobuf:"bytes,1,opt,name=key_bag,json=keyBag" json:"key_bag,omitempty"`
	// Default key is the key, that should be used for encryption. Can be empty
	// in case we have pending keys (waiting for explicit passphrase, or client
	// didn't received keystore keys).
	DefaultKeyName       *string  `protobuf:"bytes,2,opt,name=default_key_name,json=defaultKeyName" json:"default_key_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CryptographerData) Reset()         { *m = CryptographerData{} }
func (m *CryptographerData) String() string { return proto.CompactTextString(m) }
func (*CryptographerData) ProtoMessage()    {}
func (*CryptographerData) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3da1c773fb73be3, []int{0}
}

func (m *CryptographerData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CryptographerData.Unmarshal(m, b)
}
func (m *CryptographerData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CryptographerData.Marshal(b, m, deterministic)
}
func (m *CryptographerData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CryptographerData.Merge(m, src)
}
func (m *CryptographerData) XXX_Size() int {
	return xxx_messageInfo_CryptographerData.Size(m)
}
func (m *CryptographerData) XXX_DiscardUnknown() {
	xxx_messageInfo_CryptographerData.DiscardUnknown(m)
}

var xxx_messageInfo_CryptographerData proto.InternalMessageInfo

func (m *CryptographerData) GetKeyBag() *NigoriKeyBag {
	if m != nil {
		return m.KeyBag
	}
	return nil
}

func (m *CryptographerData) GetDefaultKeyName() string {
	if m != nil && m.DefaultKeyName != nil {
		return *m.DefaultKeyName
	}
	return ""
}

type CustomPassphraseKeyDerivationParams struct {
	// Method used for deriving keys from custom passphrase.
	CustomPassphraseKeyDerivationMethod *NigoriSpecifics_KeyDerivationMethod `protobuf:"varint,1,opt,name=custom_passphrase_key_derivation_method,json=customPassphraseKeyDerivationMethod,enum=sync_pb.NigoriSpecifics_KeyDerivationMethod" json:"custom_passphrase_key_derivation_method,omitempty"`
	// Salt used for the derivation of the key from the custom passphrase. Should
	// be set iff custom_passphrase_key_derivation_method == SCRYPT_8192_8_11.
	CustomPassphraseKeyDerivationSalt *string  `protobuf:"bytes,2,opt,name=custom_passphrase_key_derivation_salt,json=customPassphraseKeyDerivationSalt" json:"custom_passphrase_key_derivation_salt,omitempty"`
	XXX_NoUnkeyedLiteral              struct{} `json:"-"`
	XXX_unrecognized                  []byte   `json:"-"`
	XXX_sizecache                     int32    `json:"-"`
}

func (m *CustomPassphraseKeyDerivationParams) Reset()         { *m = CustomPassphraseKeyDerivationParams{} }
func (m *CustomPassphraseKeyDerivationParams) String() string { return proto.CompactTextString(m) }
func (*CustomPassphraseKeyDerivationParams) ProtoMessage()    {}
func (*CustomPassphraseKeyDerivationParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3da1c773fb73be3, []int{1}
}

func (m *CustomPassphraseKeyDerivationParams) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CustomPassphraseKeyDerivationParams.Unmarshal(m, b)
}
func (m *CustomPassphraseKeyDerivationParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CustomPassphraseKeyDerivationParams.Marshal(b, m, deterministic)
}
func (m *CustomPassphraseKeyDerivationParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CustomPassphraseKeyDerivationParams.Merge(m, src)
}
func (m *CustomPassphraseKeyDerivationParams) XXX_Size() int {
	return xxx_messageInfo_CustomPassphraseKeyDerivationParams.Size(m)
}
func (m *CustomPassphraseKeyDerivationParams) XXX_DiscardUnknown() {
	xxx_messageInfo_CustomPassphraseKeyDerivationParams.DiscardUnknown(m)
}

var xxx_messageInfo_CustomPassphraseKeyDerivationParams proto.InternalMessageInfo

func (m *CustomPassphraseKeyDerivationParams) GetCustomPassphraseKeyDerivationMethod() NigoriSpecifics_KeyDerivationMethod {
	if m != nil && m.CustomPassphraseKeyDerivationMethod != nil {
		return *m.CustomPassphraseKeyDerivationMethod
	}
	return NigoriSpecifics_UNSPECIFIED
}

func (m *CustomPassphraseKeyDerivationParams) GetCustomPassphraseKeyDerivationSalt() string {
	if m != nil && m.CustomPassphraseKeyDerivationSalt != nil {
		return *m.CustomPassphraseKeyDerivationSalt
	}
	return ""
}

type NigoriModel struct {
	// Represents state of the cryptographer.
	CryptographerData *CryptographerData `protobuf:"bytes,1,opt,name=cryptographer_data,json=cryptographerData" json:"cryptographer_data,omitempty"`
	// Contains the name of the key, used for encryption of
	// NigoriSpecifics.keystore_decryptor_token, should always be the name of the
	// latest keystore key. Equals to cryptographer_data.default_key_name iff it
	// is Nigori in full keystore mode (not in backward compatible keystore
	// mode).
	CurrentKeystoreKeyName *string `protobuf:"bytes,2,opt,name=current_keystore_key_name,json=currentKeystoreKeyName" json:"current_keystore_key_name,omitempty"`
	// Contains keybag in encrypted form, should be empty once we were able to
	// decrypt keybag from specifics.
	PendingKeys *EncryptedData `protobuf:"bytes,3,opt,name=pending_keys,json=pendingKeys" json:"pending_keys,omitempty"`
	// PassphraseType used for encryption. IMPLICIT_PASSPRHASE shouldn't be used
	// here.
	PassphraseType *NigoriSpecifics_PassphraseType `protobuf:"varint,4,opt,name=passphrase_type,json=passphraseType,enum=sync_pb.NigoriSpecifics_PassphraseType,def=0" json:"passphrase_type,omitempty"`
	// The time (in UNIX epoch milliseconds) at which the keystore migration was
	// performed.
	KeystoreMigrationTime *int64 `protobuf:"varint,5,opt,name=keystore_migration_time,json=keystoreMigrationTime" json:"keystore_migration_time,omitempty"`
	// The time (in UNIX epoch milliseconds) at which a custom passphrase was
	// set.
	// Note: this field may not be set if the custom passphrase was applied before
	// corresponding field in NigoriSpecifics was introduced.
	CustomPassphraseTime *int64 `protobuf:"varint,6,opt,name=custom_passphrase_time,json=customPassphraseTime" json:"custom_passphrase_time,omitempty"`
	// Params used for deriving keys from custom passphrase. Should be set iff
	// |passphrase_type| is CUSTOM_PASSPHRASE.
	CustomPassphraseKeyDerivationParams *CustomPassphraseKeyDerivationParams `protobuf:"bytes,7,opt,name=custom_passphrase_key_derivation_params,json=customPassphraseKeyDerivationParams" json:"custom_passphrase_key_derivation_params,omitempty"`
	// Indicates whether we need to encrypt all encryptable user types.
	EncryptEverything *bool `protobuf:"varint,8,opt,name=encrypt_everything,json=encryptEverything" json:"encrypt_everything,omitempty"`
	// The list of encrypted UserEncryptableTypes, represented by their specifics
	// field number.
	EncryptedTypesSpecificsFieldNumber []int32 `protobuf:"varint,9,rep,name=encrypted_types_specifics_field_number,json=encryptedTypesSpecificsFieldNumber" json:"encrypted_types_specifics_field_number,omitempty"`
	// Keystore keys are used to decrypt keystore-based Nigori. Should be
	// persisted in order to not ask the keystore server for them during every
	// browser startup. Due to backward compatibility requirements keys are
	// always Base64 encoded.
	KeystoreKey []string `protobuf:"bytes,10,rep,name=keystore_key,json=keystoreKey" json:"keystore_key,omitempty"`
	// Encryptor keystore decryptor token. Used for decryption of keystore Nigori
	// in case keystore keys arrived after NigoriSpecifics.
	PendingKeystoreDecryptorToken *EncryptedData `protobuf:"bytes,11,opt,name=pending_keystore_decryptor_token,json=pendingKeystoreDecryptorToken" json:"pending_keystore_decryptor_token,omitempty"`
	// Contains the name of the latest available trusted vault key that was used
	// as the default encryption key. Resets when the client go out of pending
	// decryption state and transits to other passphrase types.
	LastDefaultTrustedVaultKeyName *string  `protobuf:"bytes,12,opt,name=last_default_trusted_vault_key_name,json=lastDefaultTrustedVaultKeyName" json:"last_default_trusted_vault_key_name,omitempty"`
	XXX_NoUnkeyedLiteral           struct{} `json:"-"`
	XXX_unrecognized               []byte   `json:"-"`
	XXX_sizecache                  int32    `json:"-"`
}

func (m *NigoriModel) Reset()         { *m = NigoriModel{} }
func (m *NigoriModel) String() string { return proto.CompactTextString(m) }
func (*NigoriModel) ProtoMessage()    {}
func (*NigoriModel) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3da1c773fb73be3, []int{2}
}

func (m *NigoriModel) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NigoriModel.Unmarshal(m, b)
}
func (m *NigoriModel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NigoriModel.Marshal(b, m, deterministic)
}
func (m *NigoriModel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NigoriModel.Merge(m, src)
}
func (m *NigoriModel) XXX_Size() int {
	return xxx_messageInfo_NigoriModel.Size(m)
}
func (m *NigoriModel) XXX_DiscardUnknown() {
	xxx_messageInfo_NigoriModel.DiscardUnknown(m)
}

var xxx_messageInfo_NigoriModel proto.InternalMessageInfo

const Default_NigoriModel_PassphraseType NigoriSpecifics_PassphraseType = NigoriSpecifics_UNKNOWN

func (m *NigoriModel) GetCryptographerData() *CryptographerData {
	if m != nil {
		return m.CryptographerData
	}
	return nil
}

func (m *NigoriModel) GetCurrentKeystoreKeyName() string {
	if m != nil && m.CurrentKeystoreKeyName != nil {
		return *m.CurrentKeystoreKeyName
	}
	return ""
}

func (m *NigoriModel) GetPendingKeys() *EncryptedData {
	if m != nil {
		return m.PendingKeys
	}
	return nil
}

func (m *NigoriModel) GetPassphraseType() NigoriSpecifics_PassphraseType {
	if m != nil && m.PassphraseType != nil {
		return *m.PassphraseType
	}
	return Default_NigoriModel_PassphraseType
}

func (m *NigoriModel) GetKeystoreMigrationTime() int64 {
	if m != nil && m.KeystoreMigrationTime != nil {
		return *m.KeystoreMigrationTime
	}
	return 0
}

func (m *NigoriModel) GetCustomPassphraseTime() int64 {
	if m != nil && m.CustomPassphraseTime != nil {
		return *m.CustomPassphraseTime
	}
	return 0
}

func (m *NigoriModel) GetCustomPassphraseKeyDerivationParams() *CustomPassphraseKeyDerivationParams {
	if m != nil {
		return m.CustomPassphraseKeyDerivationParams
	}
	return nil
}

func (m *NigoriModel) GetEncryptEverything() bool {
	if m != nil && m.EncryptEverything != nil {
		return *m.EncryptEverything
	}
	return false
}

func (m *NigoriModel) GetEncryptedTypesSpecificsFieldNumber() []int32 {
	if m != nil {
		return m.EncryptedTypesSpecificsFieldNumber
	}
	return nil
}

func (m *NigoriModel) GetKeystoreKey() []string {
	if m != nil {
		return m.KeystoreKey
	}
	return nil
}

func (m *NigoriModel) GetPendingKeystoreDecryptorToken() *EncryptedData {
	if m != nil {
		return m.PendingKeystoreDecryptorToken
	}
	return nil
}

func (m *NigoriModel) GetLastDefaultTrustedVaultKeyName() string {
	if m != nil && m.LastDefaultTrustedVaultKeyName != nil {
		return *m.LastDefaultTrustedVaultKeyName
	}
	return ""
}

// Sync proto to store Nigori data in storage. Proto should be encrypted with
// os_crypt before storing it somewhere, because it contains sensitive data (
// nigori_model.cryptographer_data.key_bag and nigori_model.keystore_keys).
type NigoriLocalData struct {
	// Global metadata.
	ModelTypeState *ModelTypeState `protobuf:"bytes,1,opt,name=model_type_state,json=modelTypeState" json:"model_type_state,omitempty"`
	// Metadata for Nigori entity.
	EntityMetadata *EntityMetadata `protobuf:"bytes,2,opt,name=entity_metadata,json=entityMetadata" json:"entity_metadata,omitempty"`
	// Nigori model state.
	NigoriModel          *NigoriModel `protobuf:"bytes,3,opt,name=nigori_model,json=nigoriModel" json:"nigori_model,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *NigoriLocalData) Reset()         { *m = NigoriLocalData{} }
func (m *NigoriLocalData) String() string { return proto.CompactTextString(m) }
func (*NigoriLocalData) ProtoMessage()    {}
func (*NigoriLocalData) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3da1c773fb73be3, []int{3}
}

func (m *NigoriLocalData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NigoriLocalData.Unmarshal(m, b)
}
func (m *NigoriLocalData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NigoriLocalData.Marshal(b, m, deterministic)
}
func (m *NigoriLocalData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NigoriLocalData.Merge(m, src)
}
func (m *NigoriLocalData) XXX_Size() int {
	return xxx_messageInfo_NigoriLocalData.Size(m)
}
func (m *NigoriLocalData) XXX_DiscardUnknown() {
	xxx_messageInfo_NigoriLocalData.DiscardUnknown(m)
}

var xxx_messageInfo_NigoriLocalData proto.InternalMessageInfo

func (m *NigoriLocalData) GetModelTypeState() *ModelTypeState {
	if m != nil {
		return m.ModelTypeState
	}
	return nil
}

func (m *NigoriLocalData) GetEntityMetadata() *EntityMetadata {
	if m != nil {
		return m.EntityMetadata
	}
	return nil
}

func (m *NigoriLocalData) GetNigoriModel() *NigoriModel {
	if m != nil {
		return m.NigoriModel
	}
	return nil
}

func init() {
	proto.RegisterType((*CryptographerData)(nil), "sync_pb.CryptographerData")
	proto.RegisterType((*CustomPassphraseKeyDerivationParams)(nil), "sync_pb.CustomPassphraseKeyDerivationParams")
	proto.RegisterType((*NigoriModel)(nil), "sync_pb.NigoriModel")
	proto.RegisterType((*NigoriLocalData)(nil), "sync_pb.NigoriLocalData")
}

func init() {
	proto.RegisterFile("nigori_local_data.proto", fileDescriptor_c3da1c773fb73be3)
}

var fileDescriptor_c3da1c773fb73be3 = []byte{
	// 727 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x54, 0x4d, 0x6f, 0xd3, 0x40,
	0x10, 0x95, 0x09, 0x6d, 0xda, 0x4d, 0x94, 0xb6, 0xab, 0x36, 0x35, 0x91, 0x40, 0x69, 0xaa, 0xd2,
	0x48, 0x40, 0x0e, 0x15, 0x02, 0x95, 0x13, 0xb4, 0x29, 0x02, 0x85, 0x84, 0xc8, 0x0d, 0x20, 0x4e,
	0xd6, 0xd6, 0x9e, 0x3a, 0x56, 0xbc, 0xbb, 0xd6, 0xee, 0xa6, 0x92, 0xaf, 0xfc, 0x41, 0xfe, 0x0a,
	0x3f, 0x80, 0x03, 0xda, 0xf5, 0xc6, 0xf9, 0xa8, 0x68, 0x7b, 0x8a, 0xe2, 0x79, 0x6f, 0x76, 0x66,
	0xde, 0x9b, 0x41, 0xfb, 0x2c, 0x8e, 0xb8, 0x88, 0xfd, 0x84, 0x07, 0x24, 0xf1, 0x43, 0xa2, 0x48,
	0x27, 0x15, 0x5c, 0x71, 0x5c, 0x96, 0x19, 0x0b, 0xfc, 0xf4, 0xaa, 0xb1, 0x0d, 0x2c, 0x10, 0x59,
	0xaa, 0x62, 0xce, 0xf2, 0x50, 0x63, 0x0f, 0x98, 0x8a, 0x55, 0xe6, 0x53, 0x50, 0x64, 0xce, 0x68,
	0xd4, 0x29, 0x0f, 0x21, 0xf1, 0x55, 0x96, 0x82, 0x2f, 0x15, 0x51, 0x30, 0xfb, 0x6e, 0x9f, 0x90,
	0x29, 0x04, 0xf1, 0x75, 0x1c, 0xc8, 0xfc, 0x7b, 0x8b, 0xa2, 0x9d, 0x73, 0x9d, 0x98, 0x47, 0x82,
	0xa4, 0x63, 0x10, 0x5d, 0xa2, 0x08, 0xee, 0xa0, 0xf2, 0x04, 0x32, 0xff, 0x8a, 0x44, 0xae, 0xd3,
	0x74, 0xda, 0x95, 0x93, 0xbd, 0x8e, 0x2d, 0xa4, 0x33, 0x30, 0x69, 0x7a, 0x90, 0x9d, 0x91, 0xc8,
	0x5b, 0x9f, 0x98, 0x5f, 0xdc, 0x46, 0xdb, 0x21, 0x5c, 0x93, 0x69, 0xa2, 0x7c, 0xcd, 0x63, 0x84,
	0x82, 0xfb, 0xa8, 0xe9, 0xb4, 0x37, 0xbd, 0x9a, 0xfd, 0xde, 0x83, 0x6c, 0x40, 0x28, 0xb4, 0xfe,
	0x3a, 0xe8, 0xf0, 0x7c, 0x2a, 0x15, 0xa7, 0x43, 0x22, 0x65, 0x3a, 0x16, 0x44, 0x42, 0x0f, 0xb2,
	0x2e, 0x88, 0xf8, 0x86, 0xe8, 0xee, 0x86, 0x44, 0x10, 0x2a, 0xf1, 0x2f, 0x07, 0x1d, 0x07, 0x06,
	0xe7, 0xa7, 0x05, 0xd0, 0x24, 0x0f, 0x0b, 0xa8, 0x6e, 0x7d, 0xcc, 0x43, 0x53, 0x62, 0xed, 0xe4,
	0xe5, 0x4a, 0x89, 0x97, 0x45, 0xa3, 0x4b, 0xf9, 0xfb, 0x86, 0xe3, 0x1d, 0x06, 0x77, 0x15, 0x91,
	0x83, 0xf0, 0x10, 0x1d, 0xdd, 0x5b, 0x83, 0x24, 0x89, 0xb2, 0xbd, 0x1e, 0xdc, 0x99, 0xf3, 0x92,
	0x24, 0xaa, 0xf5, 0x67, 0x1d, 0x55, 0xf2, 0xf2, 0xfa, 0x5a, 0x26, 0xfc, 0x19, 0xe1, 0x60, 0x71,
	0xfa, 0x46, 0x7b, 0x3b, 0xf3, 0x46, 0xd1, 0xd0, 0x2d, 0x81, 0xbc, 0x9d, 0xe0, 0x96, 0x66, 0xa7,
	0xe8, 0x49, 0x30, 0x15, 0x02, 0x98, 0xd1, 0x40, 0x2a, 0x2e, 0x60, 0x55, 0x8c, 0xba, 0x05, 0xf4,
	0x6c, 0xdc, 0x8a, 0x82, 0x4f, 0x51, 0x35, 0x05, 0x16, 0xc6, 0x2c, 0x32, 0x54, 0xb7, 0x64, 0xde,
	0xaf, 0x17, 0xef, 0x5f, 0xe4, 0xde, 0x83, 0xd0, 0xbc, 0x5d, 0xb1, 0x58, 0x9d, 0x05, 0xff, 0x44,
	0x5b, 0x0b, 0xb3, 0xd1, 0xae, 0x73, 0x1f, 0x1b, 0x39, 0x8e, 0xff, 0x2b, 0xc7, 0x7c, 0x3e, 0xa3,
	0x2c, 0x85, 0x77, 0xe5, 0x6f, 0x83, 0xde, 0xe0, 0xeb, 0x8f, 0x81, 0x57, 0x4b, 0x97, 0x02, 0xf8,
	0x0d, 0xda, 0x2f, 0x1a, 0xa1, 0x71, 0x24, 0xf2, 0x79, 0xab, 0x98, 0x82, 0xbb, 0xd6, 0x74, 0xda,
	0x25, 0x6f, 0x6f, 0x16, 0xee, 0xcf, 0xa2, 0xa3, 0x98, 0x02, 0x7e, 0x8d, 0xea, 0xb7, 0x55, 0x33,
	0xb4, 0x75, 0x43, 0xdb, 0x5d, 0x95, 0xc9, 0xb0, 0x1e, 0x64, 0xb8, 0xd4, 0x98, 0xd3, 0x2d, 0x9b,
	0xf9, 0xcc, 0x0d, 0xf7, 0x00, 0x43, 0xdf, 0x63, 0x38, 0xeb, 0xfa, 0x57, 0x08, 0xdb, 0x3d, 0xf7,
	0xe1, 0x06, 0x44, 0xa6, 0xc6, 0x31, 0x8b, 0xdc, 0x8d, 0xa6, 0xd3, 0xde, 0xf0, 0x76, 0x6c, 0xe4,
	0xa2, 0x08, 0x60, 0x0f, 0x3d, 0x87, 0x99, 0x34, 0x66, 0xf6, 0x72, 0xbe, 0xde, 0xfe, 0x75, 0x0c,
	0x49, 0xe8, 0xb3, 0x29, 0xbd, 0x02, 0xe1, 0x6e, 0x36, 0x4b, 0xed, 0x35, 0xaf, 0x55, 0xa0, 0xf5,
	0x80, 0x65, 0x21, 0xc9, 0x47, 0x0d, 0x1d, 0x18, 0x24, 0x3e, 0x40, 0xd5, 0x45, 0xfb, 0xb8, 0xa8,
	0x59, 0x6a, 0x6f, 0x7a, 0x95, 0xc9, 0xdc, 0x32, 0xd8, 0x47, 0xcd, 0x45, 0xbb, 0x18, 0x68, 0x08,
	0xb9, 0x23, 0x85, 0xaf, 0xf8, 0x04, 0x98, 0x5b, 0xb9, 0xd3, 0x42, 0x4f, 0x17, 0x2c, 0xa4, 0xe9,
	0xdd, 0x19, 0x7b, 0xa4, 0xc9, 0xb8, 0x87, 0x0e, 0x13, 0x22, 0x95, 0x3f, 0xbb, 0x29, 0x4a, 0x4c,
	0xa5, 0x6e, 0xf1, 0x66, 0xf9, 0xc2, 0x54, 0x8d, 0xa9, 0x9f, 0x69, 0x68, 0x37, 0x47, 0x8e, 0x72,
	0xe0, 0xf7, 0xc5, 0x8b, 0xf3, 0xdb, 0x41, 0x5b, 0xb9, 0x05, 0xbf, 0xe8, 0xeb, 0x6a, 0x76, 0xe5,
	0x03, 0xda, 0x5e, 0x3d, 0x93, 0x76, 0xe9, 0xf6, 0x8b, 0x8a, 0xcd, 0x82, 0xea, 0x39, 0x5d, 0xea,
	0xb0, 0x57, 0xa3, 0x4b, 0xff, 0xf1, 0x7b, 0xb4, 0xb5, 0x72, 0x80, 0xcd, 0x92, 0x2d, 0x66, 0xb8,
	0x30, 0xf1, 0xbe, 0x0d, 0x7b, 0x35, 0x58, 0xfa, 0x8f, 0xdf, 0xa2, 0xaa, 0xbd, 0xc9, 0x26, 0xb5,
	0xdd, 0xba, 0xdd, 0x95, 0xbd, 0x31, 0x65, 0x78, 0x15, 0x36, 0xff, 0x73, 0xf6, 0x02, 0x1d, 0x71,
	0x11, 0x75, 0x82, 0xb1, 0xe0, 0x34, 0x9e, 0xd2, 0x4e, 0xc0, 0x69, 0xca, 0x19, 0x30, 0x25, 0x0d,
	0x37, 0x3f, 0xec, 0x01, 0x4f, 0x3e, 0x95, 0x86, 0xce, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x06,
	0x30, 0xe1, 0x56, 0x5b, 0x06, 0x00, 0x00,
}
